)
s_time
364.50427/12.42763
s_time <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = reference_layers,
g = layers_of_interest,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = reference_layers,
G_transfer = layers_of_interest,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = reference_layersb,
G_stack = layers_of_interestb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 100
)
s_time
365.15142 / 15.44077
363.08552/13.09333
library(smop)
rm(list = ls())
library(mop)
library(microbenchmark)
# data
## current conditions
reference_layers <- terra::rast(system.file("extdata", "reference_layers.tif",
package = "mop"))
## future conditions
layers_of_interest <- terra::rast(system.file("extdata",
"layers_of_interest.tif",
package = "mop"))
reference_layersb <- raster::stack(reference_layers)
layers_of_interestb <- raster::stack(layers_of_interest)
s_time <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = reference_layers,
g = layers_of_interest,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = reference_layers,
G_transfer = layers_of_interest,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = reference_layersb,
G_stack = layers_of_interestb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 100
)
s_time
365.08016/14.26075
361.48870/13.49456
terra::plot(mop_basic_res1)
terra::plot(mop_basic_res$mop_distances)
m_path <- system.file("extdata/M_layers", package = "smop") |>
list.files(full.names=TRUE)
g_path <- system.file("extdata/G_layers", package = "smop") |>
list.files(full.names=TRUE)
M_stack <- terra::rast(m_path)
G_stack <- terra::rast(g_path)
M_stackb <- raster::stack(M_stack)
G_stackb <- raster::stack(G_stack)
s_time2 <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = M_stack, g = G_stack,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
parallel = FALSE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = M_stack,
G_transfer = G_stack,
comp_each = NULL,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = M_stackb,
G_stack = G_stackb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 20
)
s_time2
1114.9262/133.1369
library(smop)
library(smop)
remotes::install_github("ropensci/UCSCXenaTools")
devtools::run_examples()
# Run tests and examples
devtools::test()
# Check package as CRAN
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran"))
# Check content
# install.packages('checkhelper', repos = 'https://thinkr-open.r-universe.dev')
checkhelper::find_missing_tags()
# _Check that you let the house clean after the check, examples and tests
all_files_remaining <- checkhelper::check_clean_userspace()
all_files_remaining
# Check spelling
# usethis::use_spell_check()
spelling::spell_check_package()
library(smop)
library(smop)
748.391/60
# Check spelling
# usethis::use_spell_check()
spelling::spell_check_package()
# Check spelling
# usethis::use_spell_check()
spelling::spell_check_package()
library(smop)
# Check URL are correct
# install.packages('urlchecker', repos = 'https://r-lib.r-universe.dev')
urlchecker::url_check()
urlchecker::url_update()
# check on other distributions
# _rhub
devtools::check_rhub()
bio10 <- geodata::cmip6_world("CNRM-CM6-1", "585", "2061-2080",
var="bioc", res=10, path=tempdir())
bio10_pre <- geodata::worldclim_global("bioc",res=10,path = tempdir())
t6 <- system.time({
future::plan("future::multisession",workers = 10)
mop_basic_res1 <- smop::mop(M_calibra = bio10_pre[[c(1,5,6,12,15)]],
G_transfer = bio10[[c(1,5,6,12,15)]],
comp_each = 10000,
percent = 50,standardize_vars = TRUE,
normalized = TRUE)
future::plan("future::sequential")
})
t6
716.569 / 60
devtools::build_site()
library(smop)
library(smop)
devtools::build_site()
library(smop)
# Verify you're ready for release, and release
devtools::release()
# _win devel CRAN
devtools::check_win_devel()
# _win devel CRAN
devtools::check_win_devel()
# Verify you're ready for release, and release
devtools::release()
rm(list = ls())
library(mop)
library(microbenchmark)
# data
## current conditions
reference_layers <- terra::rast(system.file("extdata", "reference_layers.tif",
package = "mop"))
## future conditions
layers_of_interest <- terra::rast(system.file("extdata",
"layers_of_interest.tif",
package = "mop"))
reference_layersb <- raster::stack(reference_layers)
layers_of_interestb <- raster::stack(layers_of_interest)
s_time <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = reference_layers,
g = layers_of_interest,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = reference_layers,
G_transfer = layers_of_interest,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = reference_layersb,
G_stack = layers_of_interestb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 100
)
s_time
366.59242/13.93574
library(smop)
# data
## current conditions
reference_layers <- terra::rast(system.file("extdata", "reference_layers.tif",
package = "mop"))
## future conditions
layers_of_interest <- terra::rast(system.file("extdata",
"layers_of_interest.tif",
package = "mop"))
rm(list = ls())
library(mop)
library(microbenchmark)
# data
## current conditions
reference_layers <- terra::rast(system.file("extdata", "reference_layers.tif",
package = "mop"))
## future conditions
layers_of_interest <- terra::rast(system.file("extdata",
"layers_of_interest.tif",
package = "mop"))
reference_layersb <- raster::stack(reference_layers)
layers_of_interestb <- raster::stack(layers_of_interest)
s_time <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = reference_layers,
g = layers_of_interest,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = reference_layers,
G_transfer = layers_of_interest,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = reference_layersb,
G_stack = layers_of_interestb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 100
)
s_time
370.27579 /16.63223
library(smop)
rm(list = ls())
library(mop)
library(microbenchmark)
# data
## current conditions
reference_layers <- terra::rast(system.file("extdata", "reference_layers.tif",
package = "mop"))
## future conditions
layers_of_interest <- terra::rast(system.file("extdata",
"layers_of_interest.tif",
package = "mop"))
reference_layersb <- raster::stack(reference_layers)
layers_of_interestb <- raster::stack(layers_of_interest)
s_time <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = reference_layers,
g = layers_of_interest,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = reference_layers,
G_transfer = layers_of_interest,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = reference_layersb,
G_stack = layers_of_interestb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 100
)
s_time
terra::plot(mop_basic_res1)
terra::plot(mop_basic_res$mop_distances)
m_path <- system.file("extdata/M_layers", package = "smop") |>
list.files(full.names=TRUE)
g_path <- system.file("extdata/G_layers", package = "smop") |>
list.files(full.names=TRUE)
M_stack <- terra::rast(m_path)
G_stack <- terra::rast(g_path)
M_stackb <- raster::stack(M_stack)
G_stackb <- raster::stack(G_stack)
s_time2 <- microbenchmark::microbenchmark(mop_basic_res <- mop::mop(m = M_stack, g = G_stack,
type = "basic",
calculate_distance = TRUE,
percentage = 50,
where_distance = "all",
distance = "euclidean",
rescale_distance =  TRUE,
parallel = FALSE,
scale = TRUE,
center = TRUE),
mop_basic_res1 <- smop::mop(M_calibra = M_stack,
G_transfer = G_stack,
comp_each = NULL,
percent = 50,
standardize_vars = TRUE,
normalized = TRUE),
mop_ntbox <- ntbox::mop(M_stack = M_stackb,
G_stack = G_stackb,
percent = 50,
normalized = TRUE,
parallel = FALSE),
times = 20
)
s_time2
1144.8309/134.5414
m_path
library(smop)
pkgdown::build_site()
rm(list = ls())
library(mop)
library(microbenchmark)
library(parallelDist)
install.packages("parallelDist")
install.packages("RcppXPtrUtils")
# data
## current conditions
arma_code <- '
double calcMOP(const arma::mat &A, const arma::mat &B){
return arma::accu(arma::square(A - B));
}
'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
library(mop)
library(microbenchmark)
library(parallelDist)
library(RcppXPtrUtils)
# data
## current conditions
arma_code <- '
double calcMOP(const arma::mat &A, const arma::mat &B){
return arma::accu(arma::square(A - B));
}
'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
reference_layers <- terra::rast(system.file("extdata", "reference_layers.tif",
package = "mop"))
## future conditions
layers_of_interest <- terra::rast(system.file("extdata",
"layers_of_interest.tif",
package = "mop"))
reference_layersb <- raster::stack(reference_layers)
layers_of_interestb <- raster::stack(layers_of_interest)
reference_layers_m <- na.omit(reference_layersb[])
layers_of_interest_m <- na.omit(layers_of_interest[])
parD_mop <- parDist(list(reference_layers_m,layers_of_interest_m),
method="custom",func=euclideanFuncPtr)
parD_mop
#' par_mop_distance: Estimate mop distance between two matrices in parallel
#' par_mop_distance: Estimate mop distance between two matrices in parallel
#' @description par_mop_distances calculates the Euclidean distance
#' between two matrices in parallel.
#' par_mop_distance: Estimate mop distance between two matrices in parallel
#' @description par_mop_distances calculates the Euclidean distance
#' between two matrices in parallel.
#' @param M A numeric matrix of dimension n x m
#' @param G A numeric matrix of dimension n x m
#' par_mop_distance: Estimate mop distance between two matrices in parallel
#' @description par_mop_distances calculates the Euclidean distance
#' between two matrices in parallel.
#' @param M A numeric matrix of dimension n x m
#' @param G A numeric matrix of dimension n x m
#' @return A numeric value that represents the Euclidean distance between the
#' two matrices
#' par_mop_distance: Estimate mop distance between two matrices in parallel
#' @description par_mop_distances calculates the Euclidean distance
#' between two matrices in parallel.
#' @param M A numeric matrix of dimension n x m
#' @param G A numeric matrix of dimension n x m
#' @return A numeric value that represents the Euclidean distance between the
#' two matrices
#' @import Rcpp
#' @useDynLib smop
#' @examples
set.seed(111)
n=1000
M <- matrix(rnorm(4*n), 2*n, 2)
G <- matrix(rnorm(4*n), 2*n, 2)
mdist <- pmop_distance(M,G)
arma_code <- 'arma::vec calcMOP (arma::mat &x, arma::mat &y){
int n_rowx = x.n_rows;
int n_rowy = y.n_rows;
arma::vec prob = 0.10;
arma::vec output1(n_rowx);
arma::vec output2(n_rowy);
for(int i=0; i< n_rowy; ++i){
arma::mat A = y.row(i);
for(int j=0; j< n_rowx; ++j){
arma::mat B = x.row(j);
double a = arma::accu(arma::square(A - B));
output1[j] = a;
}
arma::vec outq = arma::quantile(output1,prob);
output2[i] = arma::mean(outq);
return output2;
}
}'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
arma_code <- 'arma::vec calcMOP (arma::mat &x, arma::mat &y){
int n_rowx = x.n_rows;
int n_rowy = y.n_rows;
arma::vec prob = {0.10};
arma::vec output1(n_rowx);
arma::vec output2(n_rowy);
for(int i=0; i< n_rowy; ++i){
arma::mat A = y.row(i);
for(int j=0; j< n_rowx; ++j){
arma::mat B = x.row(j);
double a = arma::accu(arma::square(A - B));
output1[j] = a;
}
arma::vec outq = arma::quantile(output1,prob);
output2[i] = arma::mean(outq);
return output2;
}
}'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
distm <- parallelDist::parDist(x=list(M,G),
method="custom",func=euclideanFuncPtr)
M
G
distm <- parallelDist::parDist(x=M,
method="custom",func=euclideanFuncPtr)
arma_code <- 'arma::vec calcMOP (const arma::mat &x, const arma::mat &y){
int n_rowx = x.n_rows;
int n_rowy = y.n_rows;
arma::vec prob = {0.10};
arma::vec output1(n_rowx);
arma::vec output2(n_rowy);
for(int i=0; i< n_rowy; ++i){
arma::mat A = y.row(i);
for(int j=0; j< n_rowx; ++j){
arma::mat B = x.row(j);
double a = arma::accu(arma::square(A - B));
output1[j] = a;
}
arma::vec outq = arma::quantile(output1,prob);
output2[i] = arma::mean(outq);
return output2;
}
}'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
distm <- parallelDist::parDist(x=M,
method="custom",func=euclideanFuncPtr)
arma_code <- 'arma::vec calcMOP (const arma::mat &x, const arma::mat &y){
int n_rowx = x.n_rows;
int n_rowy = y.n_rows;
arma::vec prob = {0.10};
arma::vec output1(n_rowx);
arma::vec output2(n_rowy);
for(int i=0; i< n_rowy; ++i){
arma::mat A = y.row(i);
for(int j=0; j< n_rowx; ++j){
arma::mat B = x.row(j);
double a = arma::accu(arma::square(A - B));
output1[j] = a;
}
arma::vec outq = arma::quantile(output1,prob);
output2[i] = arma::mean(outq);
return output2[0];
}
}'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
arma_code <- 'arma::vec calcMOP (const arma::mat &x, const arma::mat &y){
int n_rowx = x.n_rows;
int n_rowy = y.n_rows;
arma::vec prob = {0.10};
arma::vec output1(n_rowx);
arma::vec output2(n_rowy);
for(int i=0; i< n_rowy; ++i){
arma::mat A = y.row(i);
for(int j=0; j< n_rowx; ++j){
arma::mat B = x.row(j);
double a = arma::accu(arma::square(A - B));
output1[j] = a;
}
arma::vec outq = arma::quantile(output1,prob);
output2[i] = arma::mean(outq);
}
return output2;
}'
#compileuser-defined function and return pointer
#(RcppArmadillo is used as dependency)
euclideanFuncPtr<-cppXPtr(arma_code,depends=c("RcppArmadillo"))
distm <- parallelDist::parDist(x=M,
method="custom",func=euclideanFuncPtr)
?parallelDist::parDist
Rcpp::sourceCpp("C:/Users/Prueba/Dropbox/mop_new/test_means.cpp")
